function draw() {
	/******* GLOBAL VARIABLES ****************/
	var user_id = $("#tabContainer").data("user");

	// Transition animation variables
	var delay = function(d, i) { return i * 5; };
	var duration = 750;
	
	// Define graph area and margin areas.
	var margin = {top: 20, right: 40, bottom: 40, left: 00}, 
	w = 900, 
	h = 360 - margin.top - margin.bottom, 
	barWidth = 25, padding = 0;
	/*****************************************/ 	


	// Initialize domain and svg for graph
	function initialize(data, time, metric, category) {
		convertToMilliseconds(data); // Process Data. 
		var tooltip = d3.select("body").append("div").attr("class", "tooltip"); // Set up the tooltip.
		
		// Set the X and Y scales.		
		var x = d3.time.scale().domain([d3.time.day.offset(new Date(), -22), d3.time.day.offset(new Date(), 0)]).rangeRound([0, w - margin.left - margin.right]);
		var y = d3.scale.linear().domain([0, d3.max(data, function(d) { return d.load_volume; })]).range([h - margin.top - margin.bottom, 0]);
		
		// Set the xAxis
		var xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(d3.time.days, 1).tickFormat(d3.time.format('%d')).tickSize(0).tickPadding(8);
	
		// Create the SVG graph.
		var svg = d3.select("#graphContainer").insert("svg", "#training_stats")
		    .attr("class", "chart")
		    .attr("width", w).attr("height", h)
			.append("g")
		    .attr("transform", "translate(" + (margin.left) + "," + margin.top + ")").attr("id", "graph");
		
		var bar = enterSelections(data, svg, x, y, tooltip, xAxis, time, metric, category);
		toolTipMouseOver(tooltip);
		
		// Update graph when time scale changes
		$("ul#time_scale li, #metric_select, #category_select").on('click change', function () {
			var flag = "Update";
			sendAjaxRequest(flag, svg, x, y, xAxis, tooltip);
		});

	} // end initialize function


	// Redraw graph with new data
	function updateGraph(data, svg, x, y, xAxis, tooltip, time, metric, category) {
		deduceTimeInterval(data, x, time);
		deduceTickFormat(xAxis, x, time);

		data = convertToMilliseconds(data); // Convert dates to millisecond time.
	
	   // Update Y domain.
	   y.domain([0, d3.max(data, function(d) { return d.load_volume; })]);
	
		// Re-select chart elements and bind them to new data
		var bar = svg.selectAll("rect").data(data, function(d) { return d.date; });
		var text = svg.selectAll("text").data(data, function(d) { return d.date; });

		// Update the rects.
		bar.transition().duration(duration).delay(delay)
			.attr("x", function(d) { return x(d.date); })
		    .attr("y", function(d) { return d.load_volume == 0 ? y(d.load_volume) - 30 : y(d.load_volume) })
		    .attr("height", function(d) { return d.load_volume == 0 ? 30 : h - margin.top - margin.bottom - y(d.load_volume) });
			
		// Update the text.
		text.transition().duration(duration).delay(delay)
			 .attr("x", function(d,i) { return x(new Date(d.date)) + barWidth/2; })
		     .attr("y", function(d) { return y(d.load_volume) + 20; })
		     .text(function(d) { return d.load_volume == 0 ? null : format(d.load_volume, metric) });
		
		bar.enter().append("rect")
		    .attr("x", function(d) { return x(d.date); })
		    .attr("y", function(d) { return d.load_volume == 0 ? y(d.load_volume) - 30 : y(d.load_volume) })
		    .attr("height", function(d) { return d.load_volume == 0 ? 30 : h - margin.top - margin.bottom - y(d.load_volume) })
		    .attr("width", barWidth).attr("class", "bar")
		    .style("fill", function(d) { return d.load_volume == 0 ? "#888" : "#00e0fe"})
			.on("mouseover", function(d, i) { return barMouseOver(d, i, x, y, bar, tooltip, user_id, time, metric, barWidth) })
			.on("mouseout", function (d, i) { return barMouseOut(d, i, bar, tooltip) });
		
		text.enter().append("text")
			.attr("x", function(d,i) { return x(new Date(d.date)) + barWidth/2; })
		 	.attr("y", function(d) { return y(d.load_volume) > (0.125 * (d3.max(data, function(d) { return d.load_volume; }))) ? y(d.load_volume) + 20 : y(d.load_volume) + 20; })
			.attr("text-anchor", "middle")
		 	.text(function(d) { return d.load_volume == 0 ? null : format(d.load_volume) });

		svg.append('g').attr('class', 'x axis')
			.attr('transform', 'translate(' + padding + ',' + (h - margin.bottom - margin.top) + ')')
			.call(xAxis).selectAll("text").attr("dx", function(d) { return time == "Days" ? "0.5em" : time == "Weeks" ? "1.5em" : "1.05em" }); 

		toolTipMouseOver(tooltip);
        
        // Remove rect and text elements not in current dataset.
		bar.exit().remove();
		text.exit().remove();

} // End updateGraph() function.


	// Draw bars, labels and xAxis
	function enterSelections(data, svg, x, y, tooltip, xAxis, time, metric, category) {

		var bar = svg.selectAll("rect")
		    .data(data).enter().append("rect")
		    .attr("x", function(d) { return x(d.date); })
		    .attr("y", function(d) { return d.load_volume == 0 ? y(d.load_volume) - 30 : y(d.load_volume) })
		    .attr("height", function(d) { return d.load_volume == 0 ? 30 : h - margin.top - margin.bottom - y(d.load_volume) })
		    .attr("width", barWidth).attr("class", "bar")
		    .style("fill", function(d) { return d.load_volume == 0 ? "#888" : "#00e0fe"})
			.on("mouseover", function(d, i) { return barMouseOver(d, i, x, y, bar, tooltip, user_id, time, metric, barWidth) })
			.on("mouseout", function (d, i) { return barMouseOut(d, i, bar, tooltip) });
		
		var label = svg.selectAll("text").data(data)
		 	.enter().append("text")
			.attr("x", function(d,i) { return x(new Date(d.date)) + barWidth/2; })
		 	.attr("y", function(d) { return y(d.load_volume) > (0.125 * (d3.max(data, function(d) { return d.load_volume; }))) ? y(d.load_volume) + 20 : y(d.load_volume) + 20; })
			.attr("text-anchor", "middle")
		 	.text(function(d) { return d.load_volume == 0 ? null : format(d.load_volume) });

		svg.append('g').attr('class', 'x axis')
			.attr('transform', 'translate(' + padding + ',' + (h - margin.bottom - margin.top) + ')')
			.call(xAxis).selectAll("text").attr("dx", function(d) { return time == "Days" ? "0.5em" : time == "Weeks" ? "1.5em" : "1.05em" }); 

		return bar
	}

	function sendAjaxRequest(flag, svg, x, y, xAxis, tooltip) {
		var time = $("ul#time_scale li.current").text();
		var metric = $("#metric_select option:selected").attr("value");
		var category = $("#category_select option:selected").attr("value");
		$.ajax({
			url: "/users/" + user_id +"/workouts/analyze.json",
			data: { metric: metric, category: category, time: time },
			dataType: "json",
			success: function(response) {
				flag == "Update" ? updateGraph(response, svg, x, y, xAxis, tooltip, time, metric, category) : initialize(response, time, metric, category);
			
			}, // end success callback
			error: function (xhr, textStatus) {
					alert('Server error: ' + textStatus)
			}  // end error handling
		}); // end ajax

	} // end sendAjaxRequest()

	sendAjaxRequest(null);
} // end draw function





	

	
	
	
